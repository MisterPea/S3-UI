const {
  S3Client,
  ListBucketsCommand,
  GetBucketLocationCommand,
  CreateBucketCommand,
  DeleteObjectsCommand,
  ListObjectsV2Command,
  PutObjectCommand,
  DeleteBucketCommand,
  GetObjectCommand,
  DeleteObjectCommand,
} = require('@aws-sdk/client-s3');

const { tree, isPathDeletable } = require('./utilities');

const region = 'us-east-1';
// const endpoint = encodeURI('http://localhost:4566');

/**
 * Method to create a new S3Client
 * @param {string} locale Location to bind the Client to
 * @return {S3Client} Return is a new instance of a S3Client
 */
// const newClient = (locale) => new S3Client({
//   region: locale,
//   endpoint,
//   forcePathStyle: true,
// });
const newClient = (locale) => new S3Client({
  region: locale,
});

/**
 * Method standardizing error error reporting
 * @param {string} message Message pointing to location of the error
 * @param {string} error Error generated by .catch
 */
const logError = (message, error) => {
  throw new Error(`${error}: ${message}`);
};

/**
 * Root method to retrieve all S3 buckets associated with the client
 * @return {Promise[]} Returns a promise that yields an array of objects
 * - Keys: `Name`, `Region`, `CreationDate`
 */
function getAllBuckets() {
  const s3 = newClient(region);
  return getBuckets(s3)
    .then((data) => appendBucketRegion(s3, data.Buckets))
    .catch((err) => { throw new Error(`Error retreing buckets: ${err}`); });
}

/**
 * Pseudo-private method to retrieve and append the region of S3 buckets
 * to buckets object array
 * @param {S3Client} client S3 Client
 * @param {Object[]} buckets Array of objects containing Name and CreationDate
 * @return {Promise[]} Returns an array of objects with the keys:
 *`Name`,`Region` and `CreationDate`
 */
function appendBucketRegion(client, buckets) {
  return Promise.all(
    buckets.map(({ Name, CreationDate }) => getRegion(client, Name)
      .then((Region) => ({
        Name,
        Region: Region.LocationConstraint || region,
        CreationDate,
      }))),
  ).then((results) => results);
}

/**
 * Pseudo-private method to retrieve a list of buckets
 * associated with the current S3 client
 * @param {S3Client} client S3 Client
 * @return {Promise[]} Array of objects with keys: `Name` and `CreationDate`
 */
function getBuckets(client) {
  return client.send(new ListBucketsCommand({}))
    .then((data) => data)
    .catch((err) => {
      logError('Getting buckets', err);
      return err;
    });
}

/**
 * Method to get the length of bucket objects
 * @param {string} locale Region the bucket resides
 * @param {*} bucketName Name of the bucket
 * @return {Number} Returns the number of objects
 */
function getLengthOfBucketObjects(locale, bucketName) {
  const s3 = newClient(locale);
  return s3.send(new ListObjectsV2Command({ Bucket: bucketName }))
    .then(({ KeyCount }) => KeyCount)
    .catch((err) => { throw new Error(`Error retireving object length: ${err}`); });
}

/**
 * Method to determine the region of the S3 bucket
 * @param {S3Client} client S3 Client
 * @param {string} Name Name of bucket, which to find region
 * @return {Promise<string>} Return is a Promise that will resolve to a string
 */
function getRegion(client, Name) {
  return client.send(new GetBucketLocationCommand({ Bucket: Name }))
    .then((location) => location)
    .catch((err) => {
      logError(`Getting region for ${Name}`, err);
      return err;
    });
}

/**
 * Method to retrieve the contents of the bucket
 * @param {string} locale The region the bucket is located
 * @param {string} bucketName Bucket name
 * @return {Promise<array>} Returns an array of objects.
 * - Keys: `Key`, `LastModified`,`ETag`,`Size`,`StorageClass` and `Owner`
 */
function getBucketContents(locale, bucketName) {
  const s3 = newClient(locale);
  return s3.send(new ListObjectsV2Command({ Bucket: bucketName }))
    .then(({ Contents }) => (!Contents ? [] : tree(Contents)))
    .catch((err) => { throw new Error(err); });
}

/**
 * Method to create a new S3 bucket
 * @param {string} bucketName Lowercase 3-63 characters a-z, 0-9, dots,hyphens.
 * @param {string} accessControlLevel Visibility of bucket
 * - Other accessControlLevel options are:
 * -- `public-read`, `public-read-write` and `authenticated-read`
 * @param {string} locale region the bucket will reside - default: `us-east-1`
 * - Other North American regions are:
 * -- `us-east-2`
 * -- `us-west-1`
 * -- `us-west-2`
 * - Errors:
 * -- `BucketAlreadyExists: BucketAlreadyExists`
 * -- - Buckets must have a globally unique name
 * -- `InvalidBucketName: The specified bucket is not valid.`
 * -- - Buckets must follow the naming convention set forth here:
 * https://docs.aws.amazon.com/AmazonS3/latest/userguide/bucketnamingrules.html
 *  - Other options are available, and this function can be extended
 * https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/S3.html#createBucket-property
 * @return {Promise}
 */
function createBucket(bucketName, accessControlLevel = 'private', locale = region) {
  const s3 = newClient(locale);

  const params = {
    Bucket: bucketName,
    ACL: accessControlLevel,
  };
  return s3.send(new CreateBucketCommand(params))
    .then((data) => data)
    .catch((err) => { throw new Error(err); });
}

/**
 * Method to delete a bucket from your account
 * @param {string} locale The region the bucket is located
 * @param {string} bucketName The bucket to be deleted
 * @return {Promise}
 */
function deleteBucket(locale, bucketName) {
  const s3 = newClient(locale);

  return s3.send(new DeleteBucketCommand({ Bucket: bucketName }))
    .then(() => ({ status: 200 }))
    .catch((err) => { throw new Error(err); });
}

/**
 * Method to create an empty folder
 * @param {string} locale The region the bucket is located
 * @param {string} folderPath The path of the new folder e.g `one/two/three/`
 * @param {string} folderName The name of the new folder e.g `four`
 * @param {string} bucketName The name of the bucket
 * @return {Promise}
 */
function addFolder(locale = region, folderPath = '', bucketName, folderName) {
  const forwardSlash = (folderPath.length > 0 && folderPath !== '/') ? '/' : '';
  const validFolderPath = `${folderPath !== '/' ? folderPath : ''}`;
  const newFolderName = `${validFolderPath}${forwardSlash}${folderName}/`;
  const s3 = newClient(locale);
  const params = {
    Bucket: `${bucketName}`,
    Key: newFolderName,

  };
  return s3.send(new PutObjectCommand(params))
    .then((data) => data)
    .catch((err) => { throw new Error(err); });
}

/**
 * Method to delete a folder and it's contents
 * @param {string} locale The region the bucket is located.
 * @param {string} bucket The name of the bucket.
 * @param {string} pathToDelete The uppermost level that deletion occurs.
 * @param {string} folderName The name of the folder to be deleted.
 */
function deleteFolder(locale, bucket, pathToDelete, folderName) {
  const s3 = newClient(locale);
  const regExp = isPathDeletable(pathToDelete, folderName);

  /**
   * Closure to filter keys that need to be deleted from those that do not.
   * @param {Object[]} contents Derived from ListObjectsV2Command.
   * @return {Array{}} Return is an array of either objects with the key: Key,
   * or null. The null elements are filtered out post-return
   */
  function filterKeys(contents) {
    return contents.map(({ Key }) => {
      if (regExp.test(Key)) {
        return { Key };
      }
      return null;
    });
  }

  return s3.send(new ListObjectsV2Command({ Bucket: bucket }))
    .then(({ Contents }) => {
      const keysToDelete = filterKeys(Contents).filter(Boolean);
      const params = {
        Bucket: bucket,
        Delete: { Objects: keysToDelete },
      };
      return s3.send(new DeleteObjectsCommand(params))
        .then((data) => data)
        .catch((err) => { throw new TypeError(`${err}-could not delete objects`); });
    }).catch((err) => { throw new Error(err); });
}

/**
 * Method to initiate a file/object download. This method simply returns the Body of the
 * object, which must be handled by middleware and the frontend
 * @param {string} locale Region of the bucket
 * @param {string} bucket Name of the bucket
 * @param {string} key Slash `/` deliniated string representing the object location
 * @return {Promise} Returns a Promise that resolves to the Body of the object
 */
function downloadFile(locale, bucket, key) {
  const filenameArray = key.split('/').filter(Boolean);
  const filename = filenameArray[filenameArray.length - 1];
  const keySplit = filenameArray.length === 1 ? filename : key;
  const s3 = newClient(locale);
  const params = {
    Bucket: bucket,
    Key: keySplit,
    ResponseContentDisposition: `attatchment; filename=${filename}`,
  };

  return s3.send(new GetObjectCommand(params))
    .then(({ Body }) => Body)
    .catch((err) => { throw new Error(err); });
}

/**
 * Method to delete one object from a bucket.
 * @param {string} locale Region of the bucket
 * @param {string} bucket Name of the bucket
 * @param {string} key Slash `/` deliniated string representing the location of the object to delete
 * @return {Promise} Returns a Promise, showing success or failure
 */
function deleteFile(locale, bucket, key) {
  const filenameArray = key.split('/').filter(Boolean);
  const filename = filenameArray[filenameArray.length - 1];
  const keySplit = filenameArray.length === 1 ? filename : key;
  const s3 = newClient(locale);

  const params = {
    Bucket: bucket,
    Key: keySplit,
  };
  return s3.send(new DeleteObjectCommand(params))
    .then((result) => result)
    .catch((err) => { throw new Error(err); });
}

module.exports = {
  getAllBuckets,
  createBucket,
  getBucketContents,
  getLengthOfBucketObjects,
  addFolder,
  deleteBucket,
  deleteFile,
  deleteFolder,
  downloadFile,
};
